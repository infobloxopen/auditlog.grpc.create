// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/Infoblox-CTO/ngp.app.audit.logging/pkg/pb/auditlog.proto

// Generated with protoc-gen-gorm version: v0.20.0
// Anticipating compatibility with atlas-app-toolkit version: v0.22.0

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	github.com/Infoblox-CTO/ngp.app.audit.logging/pkg/pb/auditlog.proto

It has these top-level messages:
	AuditLog
	AuditLogRes
	GetRequest
	DownloadRequest
	CreateRequest
	ListResponse
	CreateResponse
*/
package pb

import context "context"
import fmt "fmt"
import strings "strings"
import time "time"

import auth1 "github.com/infobloxopen/atlas-app-toolkit/auth"
import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"
import postgres1 "github.com/jinzhu/gorm/dialects/postgres"
import pq1 "github.com/lib/pq"
import ptypes1 "github.com/golang/protobuf/ptypes"
import types1 "github.com/infobloxopen/protoc-gen-gorm/types"

import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import _ "github.com/envoyproxy/protoc-gen-validate/validate"
import _ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
import _ "github.com/infobloxopen/atlas-app-toolkit/query"
import _ "github.com/golang/protobuf/ptypes/timestamp"
import _ "github.com/infobloxopen/protoc-gen-atlas-query-validate/options"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type AuditLogORM struct {
	AccountId     string
	Action        string
	AppId         string
	ClientIp      string
	CreatedAt     *time.Time
	EventMetadata *postgres1.Jsonb `gorm:"type:jsonb"`
	EventVersion  string
	HttpCode      int32
	HttpMethod    string
	HttpReqBody   string
	HttpRespBody  string
	HttpUrl       string
	Id            uint64
	Message       string
	RequestId     string
	ResourceDesc  string
	ResourceId    string
	ResourceType  string
	Result        string
	SessionId     string
	SessionType   string
	SubjectGroups pq1.StringArray `gorm:"type:text[]"`
	SubjectType   string
	UpdatedAt     *time.Time
	UserName      string
}

// TableName overrides the default tablename generated by GORM
func (AuditLogORM) TableName() string {
	return "audit_logs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AuditLog) ToORM(ctx context.Context) (AuditLogORM, error) {
	to := AuditLogORM{}
	var err error
	if prehook, ok := interface{}(m).(AuditLogWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	to.Action = m.Action
	to.Result = m.Result
	to.AppId = m.AppId
	to.ResourceId = m.ResourceId
	to.ResourceType = m.ResourceType
	to.UserName = m.UserName
	to.ClientIp = m.ClientIp
	to.ResourceDesc = m.ResourceDesc
	to.Message = m.Message
	if m.UpdatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.UpdatedAt); err != nil {
			return to, err
		}
		to.UpdatedAt = &t
	}
	to.RequestId = m.RequestId
	to.EventVersion = m.EventVersion
	if m.EventMetadata != nil {
		to.EventMetadata = &postgres1.Jsonb{[]byte(m.EventMetadata.Value)}
	}
	to.SubjectType = SubjectType_name[int32(m.SubjectType)]
	to.SessionType = m.SessionType
	if m.SubjectGroups != nil {
		to.SubjectGroups = make(pq1.StringArray, len(m.SubjectGroups))
		copy(to.SubjectGroups, m.SubjectGroups)
	}
	to.SessionId = m.SessionId
	to.HttpUrl = m.HttpUrl
	to.HttpMethod = m.HttpMethod
	to.HttpReqBody = m.HttpReqBody
	to.HttpCode = m.HttpCode
	to.HttpRespBody = m.HttpRespBody
	to.AccountId = m.AccountId
	if posthook, ok := interface{}(m).(AuditLogWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AuditLogORM) ToPB(ctx context.Context) (AuditLog, error) {
	to := AuditLog{}
	var err error
	if prehook, ok := interface{}(m).(AuditLogWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	to.Action = m.Action
	to.Result = m.Result
	to.AppId = m.AppId
	to.ResourceId = m.ResourceId
	to.ResourceType = m.ResourceType
	to.UserName = m.UserName
	to.ClientIp = m.ClientIp
	to.ResourceDesc = m.ResourceDesc
	to.Message = m.Message
	if m.UpdatedAt != nil {
		if to.UpdatedAt, err = ptypes1.TimestampProto(*m.UpdatedAt); err != nil {
			return to, err
		}
	}
	to.RequestId = m.RequestId
	to.EventVersion = m.EventVersion
	if m.EventMetadata != nil {
		to.EventMetadata = &types1.JSONValue{Value: string(m.EventMetadata.RawMessage)}
	}
	to.SubjectType = SubjectType(SubjectType_value[m.SubjectType])
	to.SessionType = m.SessionType
	if m.SubjectGroups != nil {
		to.SubjectGroups = make(pq1.StringArray, len(m.SubjectGroups))
		copy(to.SubjectGroups, m.SubjectGroups)
	}
	to.SessionId = m.SessionId
	to.HttpUrl = m.HttpUrl
	to.HttpMethod = m.HttpMethod
	to.HttpReqBody = m.HttpReqBody
	to.HttpCode = m.HttpCode
	to.HttpRespBody = m.HttpRespBody
	to.AccountId = m.AccountId
	if posthook, ok := interface{}(m).(AuditLogWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AuditLog the arg will be the target, the caller the one being converted from

// AuditLogBeforeToORM called before default ToORM code
type AuditLogWithBeforeToORM interface {
	BeforeToORM(context.Context, *AuditLogORM) error
}

// AuditLogAfterToORM called after default ToORM code
type AuditLogWithAfterToORM interface {
	AfterToORM(context.Context, *AuditLogORM) error
}

// AuditLogBeforeToPB called before default ToPB code
type AuditLogWithBeforeToPB interface {
	BeforeToPB(context.Context, *AuditLog) error
}

// AuditLogAfterToPB called after default ToPB code
type AuditLogWithAfterToPB interface {
	AfterToPB(context.Context, *AuditLog) error
}

type AuditLogResORM struct {
	AccountID     string
	Action        string
	AppId         string
	ClientIp      string
	CreatedAt     *time.Time
	EventMetadata *postgres1.Jsonb `gorm:"type:jsonb"`
	EventVersion  string
	HttpCode      int32
	HttpMethod    string
	HttpReqBody   string
	HttpRespBody  string
	HttpUrl       string
	Id            uint64
	Message       string
	RequestId     string
	ResourceDesc  string
	ResourceId    string
	ResourceType  string
	Result        string
	SessionId     string
	SessionType   string
	SubjectGroups pq1.StringArray `gorm:"type:text[]"`
	SubjectType   string
	UserName      string
}

// TableName overrides the default tablename generated by GORM
func (AuditLogResORM) TableName() string {
	return "audit_logs"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *AuditLogRes) ToORM(ctx context.Context) (AuditLogResORM, error) {
	to := AuditLogResORM{}
	var err error
	if prehook, ok := interface{}(m).(AuditLogResWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		var t time.Time
		if t, err = ptypes1.Timestamp(m.CreatedAt); err != nil {
			return to, err
		}
		to.CreatedAt = &t
	}
	to.Action = m.Action
	to.Result = m.Result
	to.AppId = m.AppId
	to.ResourceId = m.ResourceId
	to.ResourceType = m.ResourceType
	to.UserName = m.UserName
	to.ClientIp = m.ClientIp
	to.ResourceDesc = m.ResourceDesc
	to.Message = m.Message
	to.RequestId = m.RequestId
	to.EventVersion = m.EventVersion
	if m.EventMetadata != nil {
		to.EventMetadata = &postgres1.Jsonb{[]byte(m.EventMetadata.Value)}
	}
	to.SubjectType = SubjectType_name[int32(m.SubjectType)]
	to.SessionType = m.SessionType
	if m.SubjectGroups != nil {
		to.SubjectGroups = make(pq1.StringArray, len(m.SubjectGroups))
		copy(to.SubjectGroups, m.SubjectGroups)
	}
	to.SessionId = m.SessionId
	to.HttpUrl = m.HttpUrl
	to.HttpMethod = m.HttpMethod
	to.HttpReqBody = m.HttpReqBody
	to.HttpCode = m.HttpCode
	to.HttpRespBody = m.HttpRespBody
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return to, err
	}
	to.AccountID = accountID
	if posthook, ok := interface{}(m).(AuditLogResWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AuditLogResORM) ToPB(ctx context.Context) (AuditLogRes, error) {
	to := AuditLogRes{}
	var err error
	if prehook, ok := interface{}(m).(AuditLogResWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		if to.CreatedAt, err = ptypes1.TimestampProto(*m.CreatedAt); err != nil {
			return to, err
		}
	}
	to.Action = m.Action
	to.Result = m.Result
	to.AppId = m.AppId
	to.ResourceId = m.ResourceId
	to.ResourceType = m.ResourceType
	to.UserName = m.UserName
	to.ClientIp = m.ClientIp
	to.ResourceDesc = m.ResourceDesc
	to.Message = m.Message
	to.RequestId = m.RequestId
	to.EventVersion = m.EventVersion
	if m.EventMetadata != nil {
		to.EventMetadata = &types1.JSONValue{Value: string(m.EventMetadata.RawMessage)}
	}
	to.SubjectType = SubjectType(SubjectType_value[m.SubjectType])
	to.SessionType = m.SessionType
	if m.SubjectGroups != nil {
		to.SubjectGroups = make(pq1.StringArray, len(m.SubjectGroups))
		copy(to.SubjectGroups, m.SubjectGroups)
	}
	to.SessionId = m.SessionId
	to.HttpUrl = m.HttpUrl
	to.HttpMethod = m.HttpMethod
	to.HttpReqBody = m.HttpReqBody
	to.HttpCode = m.HttpCode
	to.HttpRespBody = m.HttpRespBody
	if posthook, ok := interface{}(m).(AuditLogResWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type AuditLogRes the arg will be the target, the caller the one being converted from

// AuditLogResBeforeToORM called before default ToORM code
type AuditLogResWithBeforeToORM interface {
	BeforeToORM(context.Context, *AuditLogResORM) error
}

// AuditLogResAfterToORM called after default ToORM code
type AuditLogResWithAfterToORM interface {
	AfterToORM(context.Context, *AuditLogResORM) error
}

// AuditLogResBeforeToPB called before default ToPB code
type AuditLogResWithBeforeToPB interface {
	BeforeToPB(context.Context, *AuditLogRes) error
}

// AuditLogResAfterToPB called after default ToPB code
type AuditLogResWithAfterToPB interface {
	AfterToPB(context.Context, *AuditLogRes) error
}

// DefaultCreateAuditLog executes a basic gorm create call
func DefaultCreateAuditLog(ctx context.Context, in *AuditLog, db *gorm1.DB) (*AuditLog, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AuditLogORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadAuditLog executes a basic gorm read call
func DefaultReadAuditLog(ctx context.Context, in *AuditLog, db *gorm1.DB) (*AuditLog, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &AuditLogORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AuditLogORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AuditLogORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AuditLogORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteAuditLog(ctx context.Context, in *AuditLog, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AuditLogORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AuditLogORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteAuditLogSet(ctx context.Context, in []*AuditLog, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AuditLogORM{})).(AuditLogORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AuditLogORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AuditLogORM{})).(AuditLogORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AuditLogORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AuditLog, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AuditLog, *gorm1.DB) error
}

// DefaultStrictUpdateAuditLog clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAuditLog(ctx context.Context, in *AuditLog, db *gorm1.DB) (*AuditLog, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAuditLog")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AuditLogORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AuditLogORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAuditLog executes a basic gorm update call with patch behavior
func DefaultPatchAuditLog(ctx context.Context, in *AuditLog, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*AuditLog, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj AuditLog
	var err error
	if hook, ok := interface{}(&pbObj).(AuditLogWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAuditLog(ctx, &AuditLog{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AuditLogWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAuditLog(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AuditLogWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAuditLog(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AuditLogWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AuditLogWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AuditLog, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AuditLog, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AuditLog, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AuditLog, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetAuditLog executes a bulk gorm update call with patch behavior
func DefaultPatchSetAuditLog(ctx context.Context, objects []*AuditLog, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*AuditLog, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AuditLog, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAuditLog(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAuditLog patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAuditLog(ctx context.Context, patchee *AuditLog, patcher *AuditLog, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*AuditLog, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedEventMetadata bool
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"Action" {
			patchee.Action = patcher.Action
			continue
		}
		if f == prefix+"Result" {
			patchee.Result = patcher.Result
			continue
		}
		if f == prefix+"AppId" {
			patchee.AppId = patcher.AppId
			continue
		}
		if f == prefix+"ResourceId" {
			patchee.ResourceId = patcher.ResourceId
			continue
		}
		if f == prefix+"ResourceType" {
			patchee.ResourceType = patcher.ResourceType
			continue
		}
		if f == prefix+"UserName" {
			patchee.UserName = patcher.UserName
			continue
		}
		if f == prefix+"ClientIp" {
			patchee.ClientIp = patcher.ClientIp
			continue
		}
		if f == prefix+"ResourceDesc" {
			patchee.ResourceDesc = patcher.ResourceDesc
			continue
		}
		if f == prefix+"Message" {
			patchee.Message = patcher.Message
			continue
		}
		if f == prefix+"UpdatedAt" {
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"RequestId" {
			patchee.RequestId = patcher.RequestId
			continue
		}
		if f == prefix+"EventVersion" {
			patchee.EventVersion = patcher.EventVersion
			continue
		}
		if !updatedEventMetadata && strings.HasPrefix(f, prefix+"EventMetadata") {
			patchee.EventMetadata = patcher.EventMetadata
			updatedEventMetadata = true
			continue
		}
		if f == prefix+"SubjectType" {
			patchee.SubjectType = patcher.SubjectType
			continue
		}
		if f == prefix+"SessionType" {
			patchee.SessionType = patcher.SessionType
			continue
		}
		if f == prefix+"SubjectGroups" {
			patchee.SubjectGroups = patcher.SubjectGroups
			continue
		}
		if f == prefix+"SessionId" {
			patchee.SessionId = patcher.SessionId
			continue
		}
		if f == prefix+"HttpUrl" {
			patchee.HttpUrl = patcher.HttpUrl
			continue
		}
		if f == prefix+"HttpMethod" {
			patchee.HttpMethod = patcher.HttpMethod
			continue
		}
		if f == prefix+"HttpReqBody" {
			patchee.HttpReqBody = patcher.HttpReqBody
			continue
		}
		if f == prefix+"HttpCode" {
			patchee.HttpCode = patcher.HttpCode
			continue
		}
		if f == prefix+"HttpRespBody" {
			patchee.HttpRespBody = patcher.HttpRespBody
			continue
		}
		if f == prefix+"AccountId" {
			patchee.AccountId = patcher.AccountId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAuditLog executes a gorm list call
func DefaultListAuditLog(ctx context.Context, db *gorm1.DB) ([]*AuditLog, error) {
	in := AuditLog{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AuditLogORM{}, &AuditLog{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AuditLogORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AuditLog{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AuditLogORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AuditLogORM) error
}

// DefaultCreateAuditLogRes executes a basic gorm create call
func DefaultCreateAuditLogRes(ctx context.Context, in *AuditLogRes, db *gorm1.DB) (*AuditLogRes, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AuditLogResORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadAuditLogRes executes a basic gorm read call
func DefaultReadAuditLogRes(ctx context.Context, in *AuditLogRes, db *gorm1.DB) (*AuditLogRes, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &AuditLogResORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AuditLogResORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AuditLogResORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AuditLogResORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteAuditLogRes(ctx context.Context, in *AuditLogRes, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AuditLogResORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AuditLogResORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteAuditLogResSet(ctx context.Context, in []*AuditLogRes, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AuditLogResORM{})).(AuditLogResORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	acctId, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return err
	}
	err = db.Where("account_id = ? AND id in (?)", acctId, keys).Delete(&AuditLogResORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AuditLogResORM{})).(AuditLogResORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AuditLogResORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*AuditLogRes, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*AuditLogRes, *gorm1.DB) error
}

// DefaultStrictUpdateAuditLogRes clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAuditLogRes(ctx context.Context, in *AuditLogRes, db *gorm1.DB) (*AuditLogRes, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAuditLogRes")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	accountID, err := auth1.GetAccountID(ctx, nil)
	if err != nil {
		return nil, err
	}
	db = db.Where(map[string]interface{}{"account_id": accountID})
	lockedRow := &AuditLogResORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AuditLogResORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchAuditLogRes executes a basic gorm update call with patch behavior
func DefaultPatchAuditLogRes(ctx context.Context, in *AuditLogRes, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*AuditLogRes, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj AuditLogRes
	var err error
	if hook, ok := interface{}(&pbObj).(AuditLogResWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAuditLogRes(ctx, &AuditLogRes{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AuditLogResWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAuditLogRes(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AuditLogResWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAuditLogRes(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AuditLogResWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AuditLogResWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *AuditLogRes, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *AuditLogRes, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *AuditLogRes, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *AuditLogRes, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultPatchSetAuditLogRes executes a bulk gorm update call with patch behavior
func DefaultPatchSetAuditLogRes(ctx context.Context, objects []*AuditLogRes, updateMasks []*field_mask1.FieldMask, db *gorm1.DB) ([]*AuditLogRes, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors1.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*AuditLogRes, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAuditLogRes(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAuditLogRes patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAuditLogRes(ctx context.Context, patchee *AuditLogRes, patcher *AuditLogRes, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*AuditLogRes, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	var updatedEventMetadata bool
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"CreatedAt" {
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if f == prefix+"Action" {
			patchee.Action = patcher.Action
			continue
		}
		if f == prefix+"Result" {
			patchee.Result = patcher.Result
			continue
		}
		if f == prefix+"AppId" {
			patchee.AppId = patcher.AppId
			continue
		}
		if f == prefix+"ResourceId" {
			patchee.ResourceId = patcher.ResourceId
			continue
		}
		if f == prefix+"ResourceType" {
			patchee.ResourceType = patcher.ResourceType
			continue
		}
		if f == prefix+"UserName" {
			patchee.UserName = patcher.UserName
			continue
		}
		if f == prefix+"ClientIp" {
			patchee.ClientIp = patcher.ClientIp
			continue
		}
		if f == prefix+"ResourceDesc" {
			patchee.ResourceDesc = patcher.ResourceDesc
			continue
		}
		if f == prefix+"Message" {
			patchee.Message = patcher.Message
			continue
		}
		if f == prefix+"RequestId" {
			patchee.RequestId = patcher.RequestId
			continue
		}
		if f == prefix+"EventVersion" {
			patchee.EventVersion = patcher.EventVersion
			continue
		}
		if !updatedEventMetadata && strings.HasPrefix(f, prefix+"EventMetadata") {
			patchee.EventMetadata = patcher.EventMetadata
			updatedEventMetadata = true
			continue
		}
		if f == prefix+"SubjectType" {
			patchee.SubjectType = patcher.SubjectType
			continue
		}
		if f == prefix+"SessionType" {
			patchee.SessionType = patcher.SessionType
			continue
		}
		if f == prefix+"SubjectGroups" {
			patchee.SubjectGroups = patcher.SubjectGroups
			continue
		}
		if f == prefix+"SessionId" {
			patchee.SessionId = patcher.SessionId
			continue
		}
		if f == prefix+"HttpUrl" {
			patchee.HttpUrl = patcher.HttpUrl
			continue
		}
		if f == prefix+"HttpMethod" {
			patchee.HttpMethod = patcher.HttpMethod
			continue
		}
		if f == prefix+"HttpReqBody" {
			patchee.HttpReqBody = patcher.HttpReqBody
			continue
		}
		if f == prefix+"HttpCode" {
			patchee.HttpCode = patcher.HttpCode
			continue
		}
		if f == prefix+"HttpRespBody" {
			patchee.HttpRespBody = patcher.HttpRespBody
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAuditLogRes executes a gorm list call
func DefaultListAuditLogRes(ctx context.Context, db *gorm1.DB) ([]*AuditLogRes, error) {
	in := AuditLogRes{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &AuditLogResORM{}, &AuditLogRes{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AuditLogResORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AuditLogResORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*AuditLogRes{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AuditLogResORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type AuditLogResORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]AuditLogResORM) error
}
type AuditLoggingDefaultServer struct {
	DB *gorm1.DB
}

// CreateAuditLog ...
func (m *AuditLoggingDefaultServer) CreateAuditLog(ctx context.Context, in *CreateRequest) (*CreateResponse, error) {
	out := &CreateResponse{}
	return out, nil
}

// ListAuditLogs ...
func (m *AuditLoggingDefaultServer) ListAuditLogs(ctx context.Context, in *GetRequest) (*ListResponse, error) {
	out := &ListResponse{}
	return out, nil
}

// FetchLogs ...
func (m *AuditLoggingDefaultServer) FetchLogs(ctx context.Context, in *DownloadRequest) (*AuditLog, error) {
	out := &AuditLog{}
	return out, nil
}
